def originfinder(picks, s_x_init, s_y_init, offset_init, c_init, plotit = False):
    
    """
    Function intended to find & plot the origin of an event
    
    picks is a 2d array of [x,y], x is channel # y is time in seconds
    s_x_init is the initial x guess
    s_y_init is the initial y guess
    offset_init is the initial guess of the events time of origin
    c_init is the guess of the events wavespeed
    plotit determines if the output should be plotted. (Currently unused)

    """
    plt.close()
    
    ### Priors ###
    top_lim = 1385000
    bottom_lim = 1373000

    right_lim = 436000
    left_lim = 428000

    # min_offset = np.hstack(np.array(picks_all)[:,1]).min()
    # max_offset = np.hstack(np.array(picks_all)[:,1]).max()

    wavespeed_min = 100
    wavespeed_max = 5000

    picks = picks.T
    
    ### Functions ###
    def log_prior(theta, picks):
        s_x,s_y,t_offset,c = theta

        min_offset = np.array(picks[1]).min() - 5
        max_offset = np.array(picks[1]).min() + 0
        if left_lim < s_x < right_lim and bottom_lim < s_y < top_lim and min_offset < t_offset < max_offset and wavespeed_min < c < wavespeed_max:
            return 0.0
        return -np.inf

    def log_likelihood(theta, picks):
        s_x,s_y,t_offset,c = theta
        chans_of_picks = np.array(picks[0], dtype=int)

        distance = np.sqrt((channel_locations[chans_of_picks,0]-s_x)**2 + (channel_locations[chans_of_picks,1]-s_y)**2)   


        model = distance/c + t_offset

        best_line_coeffs = np.poly1d(np.polyfit(chans_of_picks, picks[1], 5))
        fit_line = np.polyval(best_line_coeffs, chans_of_picks)
        pick_residual = picks[1] - fit_line
        sigma = np.std(pick_residual)

        sigma2 = sigma**2
        #model =  t_offset + np.linalg.norm(channel_locations[chans_of_picks,:] - np.array([s_x, s_y]), axis=0) / c
        ll = - 0.5 * np.sum((model - picks[1])**2 / sigma2 + np.log(sigma2))

        return ll

    def log_probability(theta, picks):
        lp = log_prior(theta, picks)
        if not np.isfinite(lp):
            return -np.inf
        return lp + log_likelihood(theta, picks)

    offset_init = np.array(picks[1]).min() -0
    c_init = 1000

    ### initial guesses ###
    num_resets = 32

    init_guesses = np.array([s_x_init, s_y_init, offset_init, c_init]) #choose within limits

    initial = init_guesses + np.random.randn(num_resets, len(init_guesses)) * np.array([2e3, 2e3, 1, 1e2]) #np.array([2e3, 2e3, 1e-6, 1e2])

    ### Run the MCMC  on just one for a test ###

    nwalkers, ndim = initial.shape

    sampler = emcee.EnsembleSampler(
        nwalkers, ndim, log_probability,args=[picks]
    )
    sampler.run_mcmc(initial, 5000, progress=True);
    print("Finished")
    
    #print(sampler.get_last_sample())
    
    flat_samples = sampler.get_chain(discard=500, thin=15, flat=True)
    #print(flat_samples)
    plt.figure()
    plt.scatter(flat_samples[:,0],flat_samples[:,1])
    for i in flat_samples:
        print(i)
    plt.show()
    
    """
    
    fig, axes = plt.subplots(5, figsize=(10, 7), sharex=True)
    samples = sampler.get_chain()

    for i in range(ndim):
        ax = axes[i]
        ax.plot(samples[:, :, i], "k", alpha=0.3)
        ax.set_xlim(0, len(samples))

        ax.yaxis.set_label_coords(-0.1, 0.5)

    axes[-1].set_xlabel("step number");


    import corner

    fig = corner.corner(
        flat_samples, show_titles=True
    );
    plt.show()"""
